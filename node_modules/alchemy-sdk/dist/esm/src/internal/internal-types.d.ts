import { LogsEvent, LogsSubscriptionFilter, NewHeadsEvent } from './websocket-backfiller';
import { EventType, Filter, Listener } from '@ethersproject/abstract-provider';
/** This file contains internal types used by the SDK and are not exposed to the end user. */
declare type JsonRpcId = string | number | null;
/**
 * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to
 * ethers events.
 */
export declare const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = "alchemy-pending-transactions";
/** Method name for Alchemy pending transaction subscriptions when using Websockets. */
export declare const ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD = "alchemy_pendingTransactions";
export interface JsonRpcRequest {
    jsonrpc: '2.0';
    method: string;
    params?: any[];
    id?: JsonRpcId;
}
export interface VirtualSubscription {
    event: EthersEvent;
    virtualId: string;
    physicalId: string;
    method: string;
    params: any[];
    isBackfilling: boolean;
    startingBlockNumber: number;
    sentEvents: any[];
    backfillBuffer: any[];
}
export interface JsonRpcResponse<T = any> {
    jsonrpc: '2.0';
    result?: T;
    error?: JsonRpcError;
    id: JsonRpcId;
}
interface JsonRpcError<T = any> {
    code: number;
    message: string;
    data?: T;
}
export interface NewHeadsSubscription extends VirtualSubscription {
    method: 'eth_subscribe';
    params: ['newHeads'];
    isBackfilling: boolean;
    sentEvents: NewHeadsEvent[];
    backfillBuffer: NewHeadsEvent[];
}
export interface LogsSubscription extends VirtualSubscription {
    method: 'eth_subscribe';
    params: ['logs', LogsSubscriptionFilter?];
    isBackfilling: boolean;
    sentEvents: LogsEvent[];
    backfillBuffer: LogsEvent[];
}
export declare type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;
export declare type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];
/**
 * DO NOT MODIFY.
 *
 * Event class copied directly over from ethers.js's `BaseProvider` class.
 *
 * This class is used to represent events and their corresponding listeners. The
 * SDK needs to extend this class in order to support Alchemy's custom
 * Subscription API types. The original class is not exported by ethers. Minimal
 * changes have been made in order to get TS to compile.
 */
export declare class Event {
    readonly listener: Listener;
    readonly once: boolean;
    readonly tag: string;
    _lastBlockNumber: number;
    _inflight: boolean;
    constructor(tag: string, listener: Listener, once: boolean);
    get event(): EventType;
    get type(): string;
    get hash(): string;
    get filter(): Filter;
    pollable(): boolean;
}
/**
 * Wrapper class around the ethers `Event` class in order to add support for
 * Alchemy's custom subscriptions types.
 *
 * The getters on this class deserialize the event tag generated by
 * {@link getAlchemyEventTag} into the original fields passed into the event.
 */
export declare class EthersEvent extends Event {
    /**
     * Converts the event tag into the original `fromAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get fromAddress(): string | string[] | undefined;
    /**
     * Converts the event tag into the original `toAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get toAddress(): string | string[] | undefined;
    /**
     * Converts the event tag into the original `hashesOnly` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get hashesOnly(): boolean | undefined;
}
export interface SubscriptionEvent<T = any> {
    jsonrpc: '2.0';
    method: 'eth_subscription';
    params: {
        subscription: string;
        result: T;
    };
}
export {};
